\section*{Abstract Transformers}

We'll now define the transformers we used. All nodes are initialized with the $\alpha_\bot$ state, defined as:
\begin{align*}
	&\alpha_\bot=(C_\bot, D_\bot) \\
	\forall s,s_1,s_2 \in Symbols&:
	C_\bot[s] =\emptyset \quad
	D_\bot[s_1,s_2] =\emptyset
\end{align*}
For any statement we'll denote the tagged mappings as mappings after the transformation:
\begin{equation*}
	\atrans{stmt}((C,D)) = (C^\prime,D^\prime)
\end{equation*}
For \texttt{skip} statement, the state is not modified:
\begin{equation*}
	C^\prime = C, \quad D^\prime = D
\end{equation*}
For \texttt{i := ?} statement, all information regarding $i$ is removed. Both concrete value (if known), and it's difference to other variables:
\begin{align*}
C^\prime[x] = & \left.
	\begin{cases}
		C[x], & x\ne i \\
		\top, & x = i
	\end{cases}
\right\}\\
D^\prime[s_1, s_2] = & \left.
	\begin{cases}
		D[s_1,s_2], & s_1 \ne i \wedge s_2 \ne i \\
		\top, & \text{otherwise}
	\end{cases}
\right\}
\end{align*}
For \texttt{i := K} statement, concrete value of $i$ is stored, and it's relation to other variables is removed:
\begin{align*}
C^\prime[x] = & \left.
	\begin{cases}
		C[x], & x\ne i \\
		K, & x = i 
	\end{cases}
\right\}\\
D^\prime[s_1, s_2] = & \left.
	\begin{cases}
		D[s_1,s_2], & s_1 \ne i \wedge s_2 \ne i \\
		\top, & \text{otherwise}
	\end{cases}
\right\}
\end{align*}
For \texttt{i := i} the state is not transformed.

For \texttt{i := j} statement, value info is copied over from $j$ to $i$, differences between $i$ and other variables is erased, and difference between $i$ and $j$ is set to 0.
\begin{align*}
C^\prime[x] = & \left.
	\begin{cases}
		C[x], & x\ne i \\
		C[j], & x = i
	\end{cases}
\right\}\\
D^\prime[s_1,s_2] = & \left.
	\begin{cases}
		0, & \{s_1,s_2\} = \{i,j\} \\
		\top, & i \in \{s_1, s_2\} \\
		D[s_1,s_2], & otherwise
	\end{cases}
\right\}
\end{align*}
For \texttt{i := i + 1}, constant value of $i$ is increased by 1 if known, and $i$'s differences from other variables is adjusted by 1 as well:
\begin{align*}
C^\prime[x] = & \left.
	\begin{cases}
		C[x] + 1, & x = i \wedge C[i] \ne \top \\
		C[x], & \text{otherwise}
	\end{cases}
\right\}\\
D^\prime[s_1,s_2] = & \left.
	\begin{cases}
		D[s_1,s_2] + 1, & s_1 = i \wedge D[s_1,s_2] \in \mathbb{Z}\\
		D[s_1,s_2] - 1, & s_2 = i \wedge D[s_1,s_2] \in \mathbb{Z}\\
		D[s_1,s_2], & \text{otherwise}
	\end{cases}
\right\}
\end{align*}

For \texttt{i := j + 1} and \texttt{i := j - 1} statements, state is transformed in a similar way to straight assignment, except the opposite parity is used.
\begin{align*}
C^\prime[x] = & \left.
	\begin{cases}
		C[j] + 1, & x = i \wedge C[j] \in \mathbb{Z} \\
		C[x], & \text{otherwise}
	\end{cases}
\right\}\\
D^\prime[s_1,s_2] = & \left.
	\begin{cases}
		1, & s_1 = i \wedge s_2 = j\\
		\top, & s_1 = i \wedge s_2 \ne j\\
		D[s_1,s_2], & \text{otherwise}	
	\end{cases}
\right\}\\
\end{align*}

For \texttt{i := i - 1} and \texttt{i := j - 1} statements, abstract state is transformed into similar manner to increment case counterparts, but this time with inverted signs.

For \texttt{assume TRUE} statements the state is not altered, for \texttt{assume FALSE} statements, state is transformed into bottom state ($\sqcup$ - neutral) so chaotic iteration will treat it as a dead end.

For \texttt{assume i = j} statements, if $i$ and $j$ are known to be of different value (either through constant propagation or their deltas), statement is treated as \texttt{assume FALSE}, otherwise, state is transformed to copy over the more concrete constant value from one to the other, and their delta is adjusted to be 0:
\begin{align*}
C^\prime[x] = & \left.
	\begin{cases}
		C[i]\sqcap C[j], & x \in \{i,j\} \\
		C[x], & \text{ otherwise}
	\end{cases}
\right\}\\
D^\prime[s_1,s_2] = & \left.
\begin{cases}
	0, & \{s_1, s_2\} = \{i,j\}\\
	D[s_1,s_2], & \text{ otherwise}
\end{cases}
\right\}
\end{align*}

For \texttt{assume i != j} and \texttt{assume i != K} statements state is checked for conflicts, i.e. if variable $i$ is of value $K$ or equal ot $j$, then state is transformed to $\alpha_\bot$ and statement is treated as \texttt{assume FALSE}.

For \texttt{assume i = K} statements, state is checked for conflict with the already known value of $i$. If there's a conflict, statement is treated as \texttt{assume FALSE}, constant value is stored in the state:
\begin{align*}
C^\prime[x] = & \left.
	\begin{cases}
		K, & x = i \\
		C[x], & \text{ otherwise}
	\end{cases}
\right\}\\
D^\prime = & D
\end{align*}


Finally, for \texttt{assert PRED} statements, transformer is similar to \texttt{skip}, state is not transformed.

In addition to the aforementioned transformations, after each such transformation and join operation, the abstract state is augmented by deducing new deltas and constants. New deltas are added to the state from all the pairs of varibles with known constant value, and new constant values are learned from already known constant values and deltas between variables.